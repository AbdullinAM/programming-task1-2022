/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package programming.task1;


import java.lang.reflect.Array;

class Table {
        public enum Sign {
            SIGN_X("X"),
            SIGN_ZERO("0"),
            SIGN_EMPTY("·");
            private final String x;
             Sign(String x) {
                this.x = x;
            }
        }

        public enum FieldsArguments {
            MARK_X(1),
            MARK_0(0);
            private final int x;
            FieldsArguments(int x) {
                this.x = x;
            }
        }

        private final int row;
        private final int col;
        private final String[][] table;
        public Table(int row, int col) {
            this.row = row;
            this.col = col;
            table = new String[row][col];
            for(int i = 0; i < row; i++) {
                for(int j = 0; j < col; j++) {
                    table[i][j] = Sign.SIGN_EMPTY.x;
                }
            }
        }

        private String tableString;
        @Override
        public String toString() {
            for (int i = 0; i < row; i++) {
                for (int j = 0; j < col; j++) {
                    if (tableString == null) {
                        tableString = table[i][j] + "  ";
                    } else {
                        tableString += table[i][j] + "  ";
                    }
                }
                tableString += "\n";
            }
            return tableString;
        }

        //добавление крестика/нолика(метка, равная единице, добавляет крестик, равная нолику - нолик)
        public void addSign(int row, int col, FieldsArguments mark) {
            if (mark.x == 1) table[row - 1][col - 1] = Sign.SIGN_X.x;
            else table[row - 1][col - 1] = Sign.SIGN_ZERO.x;
        }

        //возвращает значение заданной клетки
        public String getSign(int row, int col) {
            return table[row - 1][col - 1];
        }

        //очистка заданной клетки
        public void clear(int row, int col) {
            table[row - 1][col - 1] = Sign.SIGN_EMPTY.x;
        }

        //поиск максимальной последовательности крестиков/ноликов(аналогично)
        public int maxLength(FieldsArguments mark) {
            int maxLength = 0;
            int length = 0;
            String sign;
            if (mark.x == 0) sign = Sign.SIGN_ZERO.x;
            else sign = Sign.SIGN_X.x;

            //поиск по горизонтали
            for (int i = 0; i < row; i++) {
                for (int j = 0; j < col; j++) {
                    if (table[i][j] == sign) {
                        length++;
                        if (length > maxLength) maxLength = length;
                    } else length = 0;
                }
            }

            //поиск по вертикали
            length = 0;
            for (int i = 0; i < col; i++) {
                for (int j = 0; j < row; j++) {
                    if (table[j][i] == sign) {
                        length++;
                        if (length > maxLength) maxLength = length;
                    } else length = 0;
                }
            }

            //поиск по главной диагонали
            length = 0;
            for (int i = 0; i < row; i++) {
                if (table[i][i] == sign) {
                    length++;
                } else {
                    length = 0;
                }
                if (length > maxLength) maxLength = length;
            }

            //поиск по побочной диагонали
            length = 0;
            for (int i = 0; i < row; i++) {
                if (table[i][row - i - 1] == sign) {
                    length++;
                } else {
                    length = 0;
                }
                if (length > maxLength) maxLength = length;
            }

            return maxLength;
        }
}

