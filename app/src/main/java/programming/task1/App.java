/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package programming.task1;


    class Table {
        private final String SIGN_X = "X";
        private final String SIGN_ZERO = "0";
        private final String SIGN_EMPTY = "·";
        private final int row;
        private final int col;
        private final String[][] table;
        public Table(int row, int col) {
            this.row = row;
            this.col = col;
            table = new String[row][col];
        }


        //инициализация поля с пустыми клетками
        public void zeroState() {
            for(int i = 0; i < row; i++) {
                for(int j = 0; j < col; j++) {
                    table[i][j] = SIGN_EMPTY;
                }
            }
        }


        //отображение текущего состояния поля
        public void actual() {
            for(int i = 0; i < row; i++) {
                for(int j = 0; j < col; j++) {
                    System.out.print(table[i][j] + "  ");
                }
                System.out.println();
            }
        }

        //добавление крестика/нолика(метка, равная единице, добавляет крестик, равная нолику - нолик)
        public void addSign(int row, int col, int mark) {
            if (mark == 1) table[row - 1][col - 1] = SIGN_X;
            else table[row - 1][col - 1] = SIGN_ZERO;
        }

        //возвращает значение заданной клетки
        public String getSign(int row, int col) {
            return table[row - 1][col - 1];
        }

        //очистка заданной клетки
        public void clear(int row, int col) {
            table[row - 1][col - 1] = SIGN_EMPTY;
        }

        //поиск максимальной последовательности крестиков/ноликов(аналогично)
        public int maxLength(int mark) {
            int maxLength = 0;
            int length = 0;
            String sign;
            if (mark == 0) sign = SIGN_ZERO;
            else sign = SIGN_X;

            //поиск по горизонтали
            for (int i = 0; i < row; i++) {
                for (int j = 0; j < col; j++) {
                    if (table[i][j] == sign) {
                        length++;
                        if (length > maxLength) maxLength = length;
                    } else length = 0;
                }
            }

            //поиск по вертикали
            length = 0;
            for (int i = 0; i < col; i++) {
                for (int j = 0; j < row; j++) {
                    if (table[j][i] == sign) {
                        length++;
                        if (length > maxLength) maxLength = length;
                    } else length = 0;
                }
            }

            //поиск по главной диагонали
            length = 0;
            for (int i = 0; i < row; i++) {
                if (table[i][i] == sign) {
                    length++;
                } else {
                    length = 0;
                }
                if (length > maxLength) maxLength = length;
            }

            //поиск по побочной диагонали
            length = 0;
            for (int i = 0; i < row; i++) {
                if (table[i][row - i - 1] == sign) {
                    length++;
                } else {
                    length = 0;
                }
                if (length > maxLength) maxLength = length;
            }

            return maxLength;
        }
}

