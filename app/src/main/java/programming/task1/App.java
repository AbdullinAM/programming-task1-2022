/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package programming.task1;


import java.lang.reflect.Array;

class Table {
        public enum Sign {
            SIGN_X("X"),
            SIGN_ZERO("0"),
            SIGN_EMPTY("·");
            private final String x;
             Sign(String x) {
                this.x = x;
            }
        }

        private final int row;
        private final int col;
        private final Sign[][] table;
        public Table(int row, int col) {
            this.row = row;
            this.col = col;
            table = new Sign[row][col];
            for(int i = 0; i < row; i++) {
                for(int j = 0; j < col; j++) {
                    table[i][j] = Sign.SIGN_EMPTY;
                }
            }
        }

        @Override
        public String toString() {
            final StringBuilder tableString = new StringBuilder();
            for (int i = 0; i < row; i++) {
                for (int j = 0; j < col; j++) {
                    tableString.append(table[i][j].x).append("  ");
                }
                tableString.append("\n");
            }
            return tableString.toString();
        }

        //добавление крестика/нолика или очистка клетки
        public void addSign(int row, int col, Sign mark) {
            if (mark.equals(Sign.SIGN_X)) table[row - 1][col - 1] = Sign.SIGN_X;
            if (mark.equals(Sign.SIGN_ZERO)) table[row - 1][col - 1] = Sign.SIGN_ZERO;
            if (mark.equals(Sign.SIGN_EMPTY)) table[row - 1][col - 1] = Sign.SIGN_EMPTY;
        }

        //возвращает значение заданной клетки
        public String getSign(int row, int col) {
            return table[row - 1][col - 1].x;
        }

        //поиск максимальной последовательности крестиков/ноликов(аналогично)
        public int maxLength(Sign mark) {
            int maxLength = 0;
            int length = 0;
            Sign sign;
            if (mark == Sign.SIGN_ZERO) sign = Sign.SIGN_ZERO;
            else sign = Sign.SIGN_X;

            //поиск по горизонтали
            for (int i = 0; i < row; i++) {
                for (int j = 0; j < col; j++) {
                    if (table[i][j] == sign) {
                        length++;
                        if (length > maxLength) maxLength = length;
                    } else length = 0;
                }
            }

            //поиск по вертикали
            length = 0;
            for (int i = 0; i < col; i++) {
                for (int j = 0; j < row; j++) {
                    if (table[j][i] == sign) {
                        length++;
                        if (length > maxLength) maxLength = length;
                    } else length = 0;
                }
            }

            //поиск по главной диагонали
            length = 0;
            for (int i = 0; i < row; i++) {
                if (table[i][i] == sign) {
                    length++;
                } else {
                    length = 0;
                }
                if (length > maxLength) maxLength = length;
            }

            //поиск по побочной диагонали
            length = 0;
            for (int i = 0; i < row; i++) {
                if (table[i][row - i - 1] == sign) {
                    length++;
                } else {
                    length = 0;
                }
                if (length > maxLength) maxLength = length;
            }

            return maxLength;
        }
}

